/**! fjl-input-filter.min.js 1.1.12 | License: BSD-3-Clause | md5checksum: 3f8cfde9fee23f8d95ab0c5de03bd29f | Built-on: Mon Mar 26 2018 03:32:54 GMT-0400 (Eastern Daylight Time) **/import{defineEnumProps$}from"fjl-mutable";import{apply,assign,compose,concat,foldl,isArray,isString,isset,keys,map,partition}from"fjl";import{notEmptyValidator,toValidationOptions,toValidationResult}from"fjl-validator";const defaultErrorHandler=console.error.bind(console),noValidationRequired=(t,e)=>!t.required&&(!isset(e)||(isString(e)||isArray(e))&&!e.length),validateInput=(t,e)=>{const{validators:r,filters:a,breakOnFailure:l,valueObscured:n,valueObscurator:s,name:i}=t;if(noValidationRequired(t,e))return toInputValidationResult({result:!0,name:i||"",rawValue:e,value:e,filteredValue:e,obscuredValue:e});let u=runValidators(r,l,e),o=runFilters(a,e),d=n&&s?s(o):o;return toInputValidationResult(assign(u,{name:i||"",rawValue:e,value:o,filteredValue:o,obscuredValue:d}))},validateIOInput=(t,e)=>{const{validators:r,filters:a,breakOnFailure:l,valueObscured:n,valueObscurator:s}=t;if(noValidationRequired(t,e))return Promise.resolve(toInputValidationResult({result:!0,name:t.name||"",rawValue:e,value:e,filteredValue:e,obscuredValue:e}));return(r&&r.length?runIOValidators(r,l,e,t):Promise.resolve({result:!0})).then(t=>runIOFilters(a,e).then(r=>(t.rawValue=e,t.value=t.filteredValue=r,t.obscuredValue=n&&s?s(r):r,toInputValidationResult(t))))},runValidators=(t,e,r)=>{let a=!0,l=0,n=[];if(!t||!t.length)return toValidationResult({result:a});const s=t.length;for(;l<s;l++){const s=t[l](r);if(!s.result&&(n.push(s.messages),a=!1,e))break}return toValidationResult({result:a,messages:concat(n)})},runIOValidators=(t,e,r,a=defaultErrorHandler)=>{if(!t||!t.length)return Promise.resolve(toValidationResult({result:!0}));const l=t.length,n=[];let s=0,i=!0;for(;s<l;s++){const l=(0,t[s])(r);if(l instanceof Promise)n.push(l.catch(a));else if(n.push(l),!l.result&&(i=!1,e))break}return Promise.all(n).then(t=>{const e=t.filter(t=>!t.result),r={result:i,messages:e.reduce((t,e)=>t.concat(e.messages),[])};return e.length&&(r.result=!1),toValidationResult(r)}).catch(a)},runFilters=(t,e)=>t&&t.length?apply(compose,t)(e):e,runIOFilters=(t,e,r=defaultErrorHandler)=>runFilters(t?t.map(t=>e=>e.then(t)):null,Promise.resolve(e).catch(r)),toInput=(t,e={})=>{const r=defineEnumProps$([[String,"name",""],[Boolean,"required",!1],[Array,"filters",[]],[Array,"validators",[]],[Boolean,"breakOnFailure",!1]],toValidationOptions(e));return isString(t)?r.name=t:t&&assign(r,t),r.required&&(r.validators=r.validators.slice(0),r.validators.push(notEmptyValidator(null))),r},toInputValidationResult=t=>{const e=defineEnumProps$([[String,"name",""],[Boolean,"result",!1],[Array,"messages",[]]],{value:null,rawValue:null,obscuredValue:null,filteredValue:null});return assign(e,t)};class Input{constructor(t){toInput(t,this)}static of(t){return new Input(t)}validate(t){return validateInput(this,t)}validateIO(t){return validateIOInput(this,t)}}const toArrayMap=t=>keys(t).map(e=>[e,t[e]]),fromArrayMap=t=>foldl((t,[e,r])=>(t[e]=r,t),{},t),validateInputFilter=(t,e)=>{if(!t||!e)return toInputFilterResult({result:!1});const[r,a]=partition(([t,e])=>e.result,map(([t,r])=>[t,validateInput(r,e[t])],toArrayMap(t))),l=foldl((t,[e,r])=>(t[e]=r.messages,t),{},a),n=fromArrayMap(r),s=fromArrayMap(a),i=!a.length;return toInputFilterResult({result:i,validInputs:n,invalidInputs:s,validResults:r,invalidResults:a,messages:l})},validateIOInputFilter=(t,e,r=defaultErrorHandler)=>t&&e?Promise.all(map(([t,r])=>validateIOInputWithName(r,t,e[t]),toArrayMap(t))).then(t=>{const[e,r]=partition(([t,e])=>e.result,t),a=foldl((t,[e,r])=>(t[e]=r.messages,t),{},r),l=fromArrayMap(e),n=fromArrayMap(r),s=!r.length;return toInputFilterResult({result:s,validInputs:l,invalidInputs:n,validResults:e,invalidResults:r,messages:a})},r):Promise.resolve(toInputFilterResult({result:!1})),validateIOInputWithName=(t,e,r,a=defaultErrorHandler)=>validateIOInput(t,r).then(t=>Promise.resolve([e,t]),a),toInputFilter=(t,e=!1,r={})=>Object.defineProperties(r,foldl((t,[r,a])=>{const l=toInput(assign(a,{name:r}));return l.breakOnFailure=e,t[r]={value:l,enumerable:!0},t},{},map(e=>[e,t[e]],keys(t)))),toInputFilterResult=(t,e={})=>{const r=defineEnumProps$([[Boolean,"result",!1],[Object,"messages",{}],[Object,"validInputs",{}],[Object,"invalidInputs",{}],[Array,"validResults",[]],[Array,"invalidResults",[]]],e);return t?assign(r,t):r};class InputFilter{constructor(t,e=!1){toInputFilter(t,e,this)}static of(t,e){return new InputFilter(t,e)}validate(t){return validateInputFilter(this,t)}validateIO(t){return validateIOInputFilter(this,t)}}export{noValidationRequired,validateInput,validateIOInput,runValidators,runIOValidators,runFilters,runIOFilters,toInput,toInputValidationResult,Input,toArrayMap,fromArrayMap,validateInputFilter,validateIOInputFilter,validateIOInputWithName,toInputFilter,toInputFilterResult,InputFilter};