{"version":3,"file":"fjl-input-filter.js","sources":["../../src/Utils.js","../../src/Input.js","../../src/InputFilter.js","../../src/fjlInputFilter.js"],"sourcesContent":["/**\n * Same as `console.error`.  Used by *IO variant methods (methods that work with promises) in fjlInputFilter;\n * E.g., used as the error catcher on promises returned from IO processes.\n * @function module:fjlInputFilter.defaultErrorHandler\n * @returns {void}\n */\nexport const defaultErrorHandler = console.error.bind(console);\n","/**\n * Created by Ely on 7/24/2014.\n */\nimport {defineEnumProps$} from 'fjl-mutable';\nimport {assign, apply, compose, concat, isString} from 'fjl';\nimport {toValidationResult, toValidationOptions, notEmptyValidator} from 'fjl-validator';\nimport {defaultErrorHandler} from './Utils';\n\n/*---------------------------------------------------*/\n/* VIRTUAL TYPES AND INTERFACES */\n/*---------------------------------------------------*/\n/**\n * @interface InputValidationResult\n * @memberOf fjlInputFilter\n * @property {String} name - `Input` this result was generated with.\n * @property {Boolean} result - Result of validation.\n * @property {Array} messages - Any error messages if `result` is `false`.\n * @property {*} value=null - Value tested against (if `filters` exist on given `#Input` object the `value` is what is returned from the results of running filters on value).\n * @property {*} rawValue=null - Raw value tested against.\n * @property {*} obscuredValue=null - Obscured value if validation `result` is `true`.\n * @property {*} filteredValue=null - Filtered result if validation `result` is `true`.\n */\n\n/**\n * @interface InputOptions\n * @memberOf fjlInputFilter\n * @desc Contains rules for validating and/or filtering an input.\n * @property {String} name='' - Input's name.\n * @property {Boolean} required=false - Whether input is required or not.\n * @property {Array} filters=[] - Any filter functions to apply to value.\n * @property {Array} validators=[] - Any validators to validate against for given value (to validator).\n * @property {Boolean} breakOnFailure=false - Whether or not to 'break' on a validation failure result or not.\n * @property {Boolean} valueObscured=false - Whether to obscure the value being tested against (to the assigned places) or not).\n * @property {Function} valueObscurator=((x) => x) - Obscurator used for obscuring a value given to validation.\n */\n\nexport const\n\n    /**\n     * Validates an input object based.\n     * @function module:fjlInputFilter.validateInput\n     * @param input {Input|InputOptions}\n     * @param value {*}\n     * @returns {InputValidationResult}\n     */\n    validateInput = (input, value) => {\n        const {validators, filters, breakOnFailure,\n                valueObscured, valueObscurator, name} = input,\n            vResult = runValidators(validators, breakOnFailure, value),\n            fResult = runFilters(filters, value),\n            oResult = valueObscured && valueObscurator ? valueObscurator(fResult) : fResult;\n        return toInputValidationResult(assign(vResult, {\n            name: name || '',\n            rawValue: value,\n            value: fResult,\n            filteredValue: fResult,\n            obscuredValue: oResult\n        }));\n    },\n\n    /**\n     * Validates an input object that may have IOValidators.  Returns\n     * a validation result wrapped in a promise.\n     * @function module:fjlInputFilter.validateIOInput\n     * @param input {Input|InputOptions}\n     * @param value {*}\n     * @returns {Promise.<InputValidationResult>}\n     */\n    validateIOInput = (input, value) => {\n        const {validators, filters, breakOnFailure,\n                valueObscured, valueObscurator} = input,\n            pendingValidation = validators && validators.length ?\n                runIOValidators(validators, breakOnFailure, value, input) :\n                    Promise.resolve({result: true})\n        ;\n        return pendingValidation.then(result =>\n            runIOFilters(filters, value)\n                .then(filteredValue => {\n                    result.rawValue = value;\n                    result.value = result.filteredValue = filteredValue;\n                    result.obscuredValue =\n                        valueObscured && valueObscurator ?\n                            valueObscurator(filteredValue) : filteredValue;\n                    return toInputValidationResult(result);\n                })\n        );\n    },\n\n    /**\n     * Runs validator against given `value`.\n     * @function module:fjlInputFilter.runValidators\n     * @param validators {Array.<Function>}\n     * @param breakOnFailure {Boolean}\n     * @param value {*}\n     * @returns {*}\n     */\n    runValidators = (validators, breakOnFailure, value) => {\n        let result = true,\n            i = 0,\n            messageResults = [];\n        if (!validators || !validators.length) {\n            return toValidationResult({result});\n        }\n        const limit = validators.length;\n        for (; i < limit; i++) {\n            const vResult = validators[i](value);\n            if (!vResult.result) {\n                messageResults.push(vResult.messages);\n                result = false;\n                if (breakOnFailure) {\n                    break;\n                }\n            }\n        }\n        return toValidationResult({result, messages: concat(messageResults)});\n    },\n\n    /**\n     * Runs (possibly) IOValidators against given `value`.\n     * @function module:fjlInputFilter.runIOValidators\n     * @param validators {Array.<Function>}\n     * @param breakOnFailure {Boolean}\n     * @param value {*}\n     * @param [errorCallback=console.error] {Function}\n     * @returns {*}\n     */\n    runIOValidators = (validators, breakOnFailure, value, errorCallback = defaultErrorHandler) => {\n        if (!validators || !validators.length) {\n            return Promise.resolve(toValidationResult({result: true}));\n        }\n        const limit = validators.length,\n            pendingResults = [];\n        let i = 0,\n            result = true;\n        for (; i < limit; i++) {\n            const validator = validators[i],\n                vResult = validator(value);\n            if (vResult instanceof Promise) {\n                pendingResults.push(vResult.catch(errorCallback));\n                continue;\n            }\n            pendingResults.push(vResult);\n            if (!vResult.result) {\n                result = false;\n                if (breakOnFailure) {\n                    break;\n                }\n            }\n        }\n\n        return Promise.all(pendingResults)\n            .then(results => {\n                const failedResults = results.filter(rslt => !rslt.result),\n                    interimResult = {\n                        result,\n                        messages: failedResults.reduce((agg, item) => {\n                            agg = agg.concat(item.messages);\n                            return agg;\n                        }, [])\n                    };\n                if (failedResults.length) {\n                    interimResult.result = false;\n                }\n                return toValidationResult(interimResult);\n            })\n            .catch(errorCallback);\n    },\n\n    /**\n     * Runs filters on value (successively).\n     * @function module:fjlInputFilter.runFilters\n     * @param filters {Array.<Function>}\n     * @param value {*}\n     * @returns {*}\n     */\n    runFilters = (filters, value) => filters && filters.length ?\n        apply(compose, filters)(value) : value,\n\n    /**\n     * Runs filters on value (successively) and returns result wrapped in a promise.\n     * @function module:fjlInputFilter.runIOFilters\n     * @param filters {Array.<Function>}\n     * @param value {*}\n     * @param [errorCallback=console.error] {Function}\n     * @returns {Promise.<*>}\n     */\n    runIOFilters = (filters, value, errorCallback = defaultErrorHandler) =>\n        runFilters(filters ? filters.map(filter => x => x.then(filter)) : null,\n            Promise.resolve(value).catch(errorCallback)),\n\n    /**\n     * Returns an `InputOptions` object from given object and optionally turns the `out` object into\n     * said `InputOptions` with firstParam assigned on top of it.\n     * @function module:fjlInputFilter.toInput\n     * @param inputObj {Object|*} - Object to build `InputOptions` object from.\n     * @param [out = {}] {Object|*}\n     * @returns {InputOptions}\n     */\n    toInput = (inputObj, out = {}) => {\n        const _inputObj = defineEnumProps$([\n            [String,    'name', ''],\n            [Boolean,   'required', false],\n            [Array,     'filters', []],\n            [Array,     'validators', []],\n            [Boolean,   'breakOnFailure', false]\n        ], toValidationOptions(out));\n        if (isString(inputObj)) {\n            _inputObj.name = inputObj;\n        }\n        else if (inputObj) {\n            assign(_inputObj, inputObj);\n        }\n        if (_inputObj.required) {\n            _inputObj.validators.push(notEmptyValidator(null));\n        }\n        return _inputObj;\n    },\n\n    /**\n     * Returns an input validation result object with values of given object\n     * applied/assigned to it.\n     * @function module:fjlInputFilter.toInputValidationResult\n     * @param resultObj {Object|*}\n     * @returns {InputValidationResult}\n     */\n    toInputValidationResult = resultObj => {\n        const _result = defineEnumProps$([\n            [String, 'name', ''],\n            [Boolean, 'result', false],\n            [Array, 'messages', []]\n        ], {\n            value: null,\n            rawValue: null,\n            obscuredValue: null,\n            filteredValue: null\n        });\n        return assign(_result, resultObj);\n    }\n;\n\n/**\n * @memberOf fjlInputFilter\n * @class Input\n * @extends InputOptions\n */\nexport class Input {\n    constructor (inputObj) {\n        toInput(inputObj, this);\n    }\n    static of (inputObj) {\n        return new Input(inputObj);\n    }\n    validate (value) {\n        return validateInput(this, value);\n    }\n    validateIO (value) {\n        return validateIOInput(this, value);\n    }\n}\n","import {partition, foldl, map, assign, keys} from 'fjl';\nimport {validateInput, validateIOInput, toInput} from './Input';\nimport {defineEnumProps$} from 'fjl-mutable';\nimport {defaultErrorHandler} from './Utils';\n\n/**\n * @interface InputFilter {Object.<String, (Input|InputOptions)>}\n * @desc Contains input objects to validate against (key-value pair object).\n */\n\n/**\n * @interface InputFilterResult\n * @memberOf fjlInputFilter\n * @property {Boolean} result - Result of validation.\n * @property {Object.<String,InputValidationResult>} validInputs - Valid input results object.\n * @property {Object.<String,InputValidationResult>} invalidInputs - Invalid input results object.\n * @property {Array.<String,InputValidationResult>} validResults - Valid input results associative array.\n * @property {Array.<String,InputValidationResult>} invalidResults - Invalid input results associative array.\n * @property {Object.<String,Array.<String>>} messages - Error messages (if any) mapped to input names.\n */\n\nexport const\n\n    /**\n     * Returns an associative list from an object.\n     * @function module:fjlInputFilter.toArrayMap\n     * @param obj {Object}\n     * @returns {Array.<Array<String,Object>>} - Associative list.\n     */\n    toArrayMap = obj => keys(obj).map(key => [key, obj[key]]),\n\n    /**\n     * Returns an object from an associative list.\n     * @function module:fjlInputFilter.fromArrayMap\n     * @param arrayMap {Array.<Array<String,Object>>}\n     * @returns {Object.<String,Object>}\n     */\n    fromArrayMap = arrayMap => foldl((agg, [key, value]) => {\n            agg[key] = value;\n            return agg;\n        }, {}, arrayMap),\n\n    /**\n     * @function module:fjlInputFilter.validateInputFilter\n     * @param inputsObj {InputFilter}\n     * @param valuesObj {Object.<String,*>}\n     * @returns {InputFilterResult}\n     */\n    validateInputFilter = (inputsObj, valuesObj) => {\n        if (!inputsObj || !valuesObj) {\n            return toInputFilterResult({result: false});\n        }\n        const [validResults, invalidResults] =\n            partition(([_, result]) => result.result,\n                map(([key, inputObj]) =>\n                    [key, validateInput(inputObj, valuesObj[key])],\n                    toArrayMap(inputsObj)\n                )),\n            messages = foldl((agg, [key, result]) => {\n                agg[key] = result.messages;\n                return agg;\n            }, {}, invalidResults),\n            validInputs = fromArrayMap(validResults),\n            invalidInputs = fromArrayMap(invalidResults),\n            result = !invalidResults.length\n        ;\n        return toInputFilterResult({\n            result,\n            validInputs,\n            invalidInputs,\n            validResults,\n            invalidResults,\n            messages\n        });\n    },\n\n    /**\n     * @function module:fjlInputFilter.validateIOInputFilter\n     * @param inputsObj {InputFilter}\n     * @param valuesObj {Object.<String, *>}\n     * @param errorHandler {Function}\n     * @returns {Promise.<InputFilterResult>}\n     */\n    validateIOInputFilter = (inputsObj, valuesObj, errorHandler = defaultErrorHandler) => {\n        if (!inputsObj || !valuesObj) {\n            return Promise.resolve(toInputFilterResult({result: false}));\n        }\n\n        return Promise.all(map(([key, inputObj]) =>\n            validateIOInputWithName(inputObj, key, valuesObj[key]),\n                toArrayMap(inputsObj)\n        )).then(assocList => {\n            const [validResults, invalidResults] =\n                    partition(([_, result]) => result.result, assocList),\n                messages = foldl((agg, [key, result]) => {\n                    agg[key] = result.messages;\n                    return agg;\n                }, {}, invalidResults),\n                validInputs = fromArrayMap(validResults),\n                invalidInputs = fromArrayMap(invalidResults),\n                result = !invalidResults.length\n            ;\n\n            return toInputFilterResult({\n                result,\n                validInputs,\n                invalidInputs,\n                validResults,\n                invalidResults,\n                messages\n            });\n        },\n            errorHandler);\n    },\n\n    /**\n     * @function module:fjlInputFilter.validateIOInputWithName\n     * @param input {Input|InputOptions}\n     * @param name {String}\n     * @param value {*}\n     * @param errorHandler {Function}\n     * @returns {Promise.<Array.<String,InputValidationResult>>}\n     */\n    validateIOInputWithName = (input, name, value, errorHandler = defaultErrorHandler) =>\n        validateIOInput(input, value)\n            .then(result => Promise.resolve([name, result]), errorHandler),\n\n    /**\n     * @function module:fjlInputFilter.toInputFilter\n     * @param inObj {Object.<String, Object>}\n     * @param breakOnFailure {Boolean}\n     * @param outObj {Object|*}\n     * @returns {InputFilter}\n     */\n    toInputFilter = (inObj, breakOnFailure = false, outObj = {}) =>\n        Object.defineProperties(outObj,\n            foldl((agg, [key, inputOpsObj]) => {\n                const inputObj = toInput(assign(inputOpsObj, {name: key}));\n                inputObj.breakOnFailure = breakOnFailure;\n                agg[key] = {\n                    value: inputObj,\n                    enumerable: true\n                };\n                return agg;\n            }, {}, map(key =>\n                [key, inObj[key]],\n                keys(inObj)\n            ))\n        ),\n\n    /**\n     * @function module:fjlInputFilter.toInputFilterResult\n     * @param inResult {Object}\n     * @param outResult {Object|*}\n     * @returns {InputFilterResult}\n     */\n    toInputFilterResult = (inResult, outResult = {}) => {\n        const _outResult = defineEnumProps$([\n            [Boolean, 'result', false],\n            [Object,  'messages', {}],\n            [Object,  'validInputs', {}],\n            [Object,  'invalidInputs', {}],\n            [Array,   'validResults', []],\n            [Array,   'invalidResults', []]\n        ], outResult);\n        return inResult ? assign(_outResult, inResult) : _outResult;\n    }\n\n;\n\n/**\n * @class InputFilter\n */\nexport class InputFilter {\n    constructor (inputsObj, breakOnFailure = false) {\n        toInputFilter(inputsObj, breakOnFailure, this);\n    }\n    static of (inputsObj, breakOnFailure) {\n        return new InputFilter(inputsObj, breakOnFailure);\n    }\n    validate (data) {\n        return validateInputFilter(this, data);\n    }\n    validateIO (data) {\n        return validateIOInputFilter(this, data);\n    }\n}\n\nexport default {\n    InputFilter,\n    toInputFilter,\n    toInputFilterResult,\n    validateInputFilter,\n    validateIOInputFilter,\n    validateIOInputWithName,\n    toArrayMap,\n    fromArrayMap\n};\n","/**\n * @module fjlInputFilter\n */\nexport * from './Input';\nexport * from './InputFilter';\n"],"names":["defaultErrorHandler","console","error","bind","validateInput","input","value","validators","filters","breakOnFailure","valueObscured","valueObscurator","name","vResult","runValidators","fResult","runFilters","oResult","toInputValidationResult","assign","validateIOInput","pendingValidation","length","runIOValidators","Promise","resolve","result","then","runIOFilters","rawValue","filteredValue","obscuredValue","i","messageResults","toValidationResult","limit","push","messages","concat","errorCallback","pendingResults","validator","catch","all","failedResults","results","filter","rslt","interimResult","reduce","agg","item","apply","compose","map","x","toInput","inputObj","out","_inputObj","defineEnumProps$","String","Boolean","Array","toValidationOptions","isString","required","notEmptyValidator","_result","resultObj","Input","toArrayMap","keys","obj","key","fromArrayMap","foldl","arrayMap","validateInputFilter","inputsObj","valuesObj","toInputFilterResult","partition","_","validResults","invalidResults","validInputs","invalidInputs","validateIOInputFilter","errorHandler","validateIOInputWithName","assocList","toInputFilter","inObj","outObj","Object","defineProperties","inputOpsObj","inResult","outResult","_outResult","InputFilter","data"],"mappings":"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"}